{"code":200,
"data":{
  "title":"React（二） - 前端框架",
  "id":"20161016",
  "author":"宅女",
  "time":"2016-10-16",
  "type":"3",
  "body":"<div class='items_3'><p class='ta_c'>如果你现在感觉到累<br/>那说明你现在走上坡路~<br/>所以即使周日<br/>我们也要抽出一点时间<br/>学习新的技术~</p><p><img src='../image/20161016/1.jpg'/></p><br/><h4><span>八</span>获取真实的DOM节点</h4><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性。</p><pre>var MyComponent = React.createClass({<br/>handleClick: function() {<br/>this.refs.myTextInput.focus();<br/>},<br/>render: function() {<br/>return (<br/>&lt;div&gt;<br/>&lt;input type=‘text’ ref=‘myTextInput’ /&gt;<br/>&lt;input type='button' value='Focus the text input' onClick={this.handleClick} /&gt;<br/>&lt;/div&gt;<br/>);<br/>}<br/>});<br/>ReactDOM.render(<br/>&lt;MyComponent /&gt;,<br/>document.getElementById('example')<br/>);</pre><p>上面代码中，组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。为了做到这一点，文本输入框必须有一个 ref 属性，然后 this.refs.[refName] 就会返回这个真实的 DOM 节点。需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性。React 组件支持很多事件，除了 Click 事件以外，还有 KeyDown 、Copy、Scroll 等，完整的事件清单请查看官方文档。</p><h4><span>九</span>表单</h4><p>用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。</p><pre>var Input = React.createClass({<br/>getInitialState: function() {<br/>return {value: 'Hello!'};<br/>},<br/>handleChange: function(event) {<br/>this.setState({value: event.target.value});<br/>},<br/>render: function () {<br/>var value = this.state.value;<br/>return (<br/>&lt;div&gt;<br/>&lt;input type='text' value={value} onChange={this.handleChange} /&gt;<br/>&lt;p&gt;{value}&lt;/p&gt;<br/>&lt;/div&gt;<br/>);<br/>}<br/>});<br/>ReactDOM.render(&lt;Input/&gt;, document.body);</pre><p>上面的代码将渲染出一个值为 Hello Runoob! 的 input 元素，并通过 onChange 事件响应更新用户输入的值。文本输入框的值，不能用 this.props.value 读取，而要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值。textarea 元素、select元素、radio元素都属于这种情况，更多介绍请参考官方文档。</p><pre>var Content = React.createClass({<br/>render: function() {<br/>return  &lt;div&gt;<br/>&lt;input type='text' value={this.props.myDataProp} onChange={this.props.updateStateProp} /&gt;<br/>&lt;h4&gt;{this.props.myDataProp}&lt;/h4&gt;<br/>&lt;/div&gt;;<br/>}<br/>});<br/>var HelloMessage = React.createClass({<br/>getInitialState: function() {<br/>return {value: 'Hello Runoob!'};<br/>},<br/>handleChange: function(event) {<br/>this.setState({value: event.target.value});<br/>},<br/>render: function() {<br/>var value = this.state.value;<br/>return &lt;div&gt;<br/>&lt;Content myDataProp = {value}<br/>updateStateProp = {this.handleChange}&gt;&lt;/Content&gt;<br/>&lt;/div&gt;;<br/>}<br/>});<br/>ReactDOM.render(<br/>&lt;HelloMessage /&gt;,<br/>document.getElementById('example')<br/>);</pre><p>你需要在父组件通过创建事件句柄 (handleChange) ，并作为 prop (updateStateProp) 传递到你的子组件上。</p><h4><span>十</span>组件的生命周期</h4><p>组件的生命周期分成三个状态：<br/>Mounting：已插入真实 DOM<br/>Updating：正在被重新渲染<br/>Unmounting：已移出真实 DOM</p><p>React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。<br/>componentWillMount 在渲染前调用,在客户端也在服务端。<br/>componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异部操作阻塞UI)。可以在你确认不需要更新组件时使用。<br/>componentWillUpdate(object nextProps, object nextState)：在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。<br/>componentDidUpdate(object prevProps, object prevState)：在组件完成更新后立即调用。在初始化时不会被调用。<br/>componentWillUnmount在组件从 DOM 中移除的时候立刻被调用。<p><p>此外，React 还提供两种特殊状态的处理函数。<br/>componentWillReceiveProps(object nextProps)： 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用。<br/>shouldComponentUpdate(object nextProps, object nextState)： 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。</p><pre>var Hello = React.createClass({<br/>getInitialState: function () {<br/>return {<br/>opacity: 1.0<br/>};<br/>},<br/>componentDidMount: function () {<br/>this.timer = setInterval(function () {<br/>var opacity = this.state.opacity;<br/>opacity -= .05;<br/>if (opacity &lt; 0.1) {<br/>opacity = 1.0;<br/>}this.setState({<br/>opacity: opacity<br/>});<br/>}.bind(this), 100);<br/>},<br/>render: function () {<br/>return (<br/>&lt;div style={{opacity: this.state.opacity}}&gt;<br/>Hello {this.props.name}<br/>&lt;/div&gt;<br/>);<br/>}<br/>});<br/>ReactDOM.render(<br/>&lt;Hello name='world'/&gt;,<br/>document.body<br/>);</pre><p>上面代码在hello组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒，就重新设置组件的透明度，从而引发重新渲染。</p><p>另外，组件的style属性的设置方式也值得注意，不能写成</p><pre>style='opacity:{this.state.opacity};'</pre><p>而要写成</p><pre>style={{opacity: this.state.opacity}}</pre><p>这是因为 React 组件样式是一个对象，所以第一重大括号表示这是 JavaScript 语法，第二重大括号表示样式对象。</p><h4><span>十一</span>Ajax</h4><p>组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI。</p><pre>var UserGist = React.createClass({<br/>getInitialState: function() {<br/>return {<br/>username: '',<br/>lastGistUrl: ''<br/>};<br/>},<br/>componentDidMount: function() {<br/>$.get(this.props.source, function(result) {<br/>var lastGist = result[0];<br/>if (this.isMounted()) {<br/>this.setState({<br/>username: lastGist.owner.login,<br/>lastGistUrl: lastGist.html_url<br/>});<br/>}<br/>}.bind(this));<br/>},<br/>render: function() {<br/>return (<br/>&lt;div&gt;<br/>{this.state.username}'s last gist is<br/>&lt;a href={this.state.lastGistUrl}&gt;here&lt;/a&gt;.<br/>&lt;/div&gt;<br/>);<br/>}<br/>});<br/>ReactDOM.render(<br/>&lt;UserGist source='https://api.github.com/users/octocat/gists' /&gt;,<br/>document.body<br/>);</pre><p>以上代码使用 jQuery 完成 Ajax 请求，这是为了便于说明。React 本身没有任何依赖，完全可以不用jQuery，而使用其他库。</p><hr/><p><img src='../image/20161016/2.jpg'/></p><br/><br/></div>"
},
"error":"Success",
"status":"SUCESS"
}